# 第3章 进程
进程：程序执行得一个实例。讨论进程的静态特性——>描述内核如何进程进程切换——>如何创建和撤销进程

## 进程、轻量级进程和线程
进程类似于人类：它们被产生，有或多或少的有效生命，可以产生一个或多个子进程，最终都要死亡。

从内核的观点看，进程的目的是担当分配系统资源的实体。

轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等

## 进程描述符
描述进程的属性。结构体task_struct。

几个重要字段：
- thread_info：进程基本信息
- mm_struct：指向内存区描述符的指针
- tty_struct：与进程相关的tty
- fs_struct：当前目录
- files_struct：指向文件描述符的指针
- signal_struct：所接收的信号

## 进程状态
进程描述符中的state字段描述了进程当前所处的状态。
- 可运行状态(TASK_RUNNING)：进程要么在CPU上运行，要么准备执行
- 可中断的等待状态(TASK_INTERRUPTIBLE)：进程被挂起，直到某个条件变为真。中断能打断该状态
- 不可中断的等待状态(TASK_UNINTERRUPTIBLE)：与可中断的等待状态类似，但不能被中断，在进程必须等待，直到一个不能被中断的事件发生
- 暂停状态(TASK_STOPPED)：进程的执行被暂停。收到SIGSTOP SIGTSTP SIGTTIN SIGTTOU等信号，进入暂停状态
- 跟踪状态(TASK_TRACED)：debug

下面两个进程状态既可以放在进程描述符的state字段中，也可以放在exit_state字段中。
- 僵死状态(EXIT_ZOMBIE)：进程的执行被终止，但父进程还未发布wait4()或者waitpid()系统调用返回有关死亡进程的信息。调用wait()类系统调用前，不能丢弃终止进程描述符中的数据，因为父进程还可能用到。
- 僵死撤销状态(EXIT_DEAD)：父进程调用wait4()或者waitpid()系统调用，进程由僵死状态转为僵死撤销状态。

## 进程描述符处理
对每个进程来说，Linux将两个不同的数据结构紧凑地存在在一个单独为进程分配的存储区域：一个是与进程相关的小数据结构thread_info，叫做线程描述符；另一个是内核态的进程堆栈。该区域大小通常为8192字节（两个页框）。内核态的进程处于内核数据段的栈。因为内核控制路径很少使用栈，所以几千个字节的内核态堆栈足够。

下图是2页存储区中存放两种数据结构的方式。线程描述符在内存区开始，而栈从末端往下增长。其中thread_info与task_struct（进程描述符）通过task字段和thread_info字段相互关联。
![avrtar][pic_1]
esp寄存器是CPU栈指针，用来存放栈顶单元的地址。数据写入堆栈，esp值就递减，其中thread_info为52字节长，所以内核栈空间为8140字节。

## 标识当前进程
内核从esp寄存器的值可以很容易的获得当前正在CPU上运行进程的thread_info结构的地址。由于thread_union结构长度为8K,则内核屏蔽掉esp的低13位则可以获得thread_info结构的基地址。进程最常用的是进程描述符。可以通过thread_info的task字段找到进程描述符的地址

## 进程链表
双向链表。链表头为init_task描述符

## TASK_RUNNING进程链表
根据优先级创建不同的链表（140个链表），提升运行速度。

prio_array_t数据结构字段
![avrtar][pic_2]
## 进程间关系
进程具有父子关系、兄弟关系。

进程描述符中表示进程亲属关系的字段描述
![avrtar][pic_3]

非亲属关系的进程描述符字段
![avrtar][pic_4]

## pidhash表及链表
从PID到处对应的进程描述符的指针。Linux采用4个散列表。进程描述符包含了表示不同类型PID字段。

4个散列表和进程描述符中的相关字段
![avrtar][pic_5]

内核初始化期间动态地为4个散列表分配空间，并将它们的地址存入pid_hash数组中。Linux利用链表来处理冲突的PID。

由于需要跟踪进程间的关系，PID结构字段设计如下
![avrtar][pic_6]

PID散列表结构
![avrtar][pic_7]

## 如何组织进程
- 没有为TASK_STOPPED EXIT_ZOMBIE EXIT_DEAD状态建立专门的链表
- 根据不同的特殊事件把处于TASK_INTERRUPTIBLE TASK_UNINIERRUPTIBLE状态的进程细分为许多类，每一类都对应某个特殊的事件。

## 等待队列
等待队列由双向链表实现，其元素包括指向进程描述符的指针。每个等待队列都有一个等待队列头，等待队列头是一个wait_queue_head_t的结构体
```c
struct _ _wait_queue_head{
    spinlock_t lock;//自旋锁，实现同步
    struct     list_head task_list;//等待进程链表的头
};
typedef struct _ _wait_queue_head wait_queue_head_t;
```
等待队列链表元素类型为wait_queue_t，每个元素代表一个睡眠进程。
```c
struct _ _wait_queue{
    unsigned int        flags;
    struct task_struct* task;
    wait_queue_func_t   func;
    struct list_head    task_list;
};
typedef struct _ _wait_queue wait_queue_t;
```
有两种睡眠进程：
- 互斥进程（等待队列元素的flags字段为1）由内核选择唤醒
- 非互斥进程（flags字段为0）在事件发生时唤醒。

等待访问临界区的进程是互斥进程的典型例子。等待相关事件的进程是非互斥的。

## 进程切换
内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。

### 硬件上下文
进程恢复执行前必须装入寄存器的一组数据称为硬件上下文（hardware context)。硬件上下文是进程可执行上下文的一个子集。在Linux中，进程硬件上下文的一部分存在TSS段，剩余部分存放在内核态的堆栈中。

进程切换定义为：保存prev硬件上下文，用next硬件上下文替代prev。因为进程切换经常发生，所以减少保存和装入硬件上下文的时间非常重要。

Linux2.6使用软件执行进程切换：
- 通过一组mov指令逐步执行切换，这样能较好地控制所装入数据的合法性。

进程切换只发生在内核态。在执行进程切换前，用户态进程使用的所有寄存器都已经保存到内核态堆栈上。

## 任务状态段
任务状态段用来存放硬件上下文。Linux并不使用硬件上下文切换，但为每个CPU（而非原始为每个进程）创建一个TSS。
- CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址
- 当用户态进程试图通过in或者out指令访问一个IO端口时，CPU需要访问存放在TSS中的IO许可位全图（Permission Bitmap）以检查是否有访问端口的权利。

当进程在用户态执行in或out指令时，控制单元执行下列操作
1. 检查eflags寄存器中的2位IOPL字段。
2. 访问tr寄存器以确定当前TSS和相应的IO许可权位图。
3. 检查IO指令中指定的IO端口在IO许可权位图中对应的位。

### thread字段
每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。

## 执行进程切换
进程切换只发生在精心设计的点：schedule()函数。

本质上，进程切换由两步组成：
1. 切换页全局目录以安装一个新的地址空间
2. 切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息。

## 创建进程
传统Unix操作系统以统一的方式对待所有进程：子进程复制父进程所拥有的资源。但这种方式使得进程创建非常慢而且效率低下。

现代Unix内核引入三种不同的机制解决了这个问题：
- 写时复制技术允许父子进程读取相同的物理页。只有当两者之一试图写一个物理页时，才进行复制，否则共享同一个物理页。
- 轻量级进程允许父子进程共享每进程在内核的许多数据结构。
- vfork()系统调用创建的进程能共享其父进程的内存地址空间。在子进程退出或执行一个新的程序前，阻塞父进程。

## 内核线程
传统Unix系统把一些重要的任务委托给周期性执行得进程，这些任务包括刷新磁盘高速缓存，交换出不用的页框，维护网络连接等等。因为一些系统进程只运行在内核态，所以现代操作系统把他们的函数委托给内核线程(kernel thread)，内核线程不受不必要的用户态上下文的拖累。

在Linux中国，内核线程在以下两方面不同于普通进程：
- 内核线程只运行在内核态，而普通进程即可以运行在内核态，也可以运行在用户态。
- 内核线程只运行在内核态，它们只使用大于PAGE_OFFSET的线性地址空间。而普通进程不管在内核态还是用户态，都可以使用4GB的线性地址空间

 