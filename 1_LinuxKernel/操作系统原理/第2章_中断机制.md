# 中断机制
中断目的：
1. 实现并发活动
2. 实现实时处理
3. 故障自动处理

中断源：引起系统中断事件

中断类型：
1. 强迫性中断和自愿中断
2. 外中断和内中断
3. 可屏蔽中断和不可屏蔽中断

断点：程序中断的地方，将要执行的下一指定的地址（CS：IP）

现场（上下文）
- 程序正确运行所依赖的信息集合（相关寄存器）

现场处理过程
- 现场保护：进入中断服务程序之前，将现场保存到栈中
- 现场恢复：中断服务器程序执行之后，恢复现场

中断响应过程：
1. 识别中断源
2. 保护断点和现场
3. 装入中断服务程序的入口地址（CS：IP）
4. 进入中断服务程序
5. 恢复现场和断点
6. 中断返回：IRET

中断响应的实质：
1. 交换指令执行地址
2. 交换CPU的态

# 系统调用
系统调用：操作系统提供给用户控制计算机的接口

系统调用的特点：
1. 涉及核心资源或者硬件的操作
2. 运行在内核态
3. 每个系统调用具有唯一的编号：ID
4. 调用过程中会产生中断：自愿中断

# 进程
## 进程概念
进程：程序在某个数据集合上的一次运行活动

## 进程特征：
1. 动态性：产生与消亡
2. 并发性：多个进程一起向前
3. 异步性：各自速度分别向前推进
4. 独立性：进程是系统分配资源的单位

## 进程与程序的区别
1. 进程是动态的，程序的一次执行过程；程序是静态的
2. 暂存与长存
3. 一个程序可能对应多个进程

## 进程的分类：
1. 系统进程与用户进程
2. 偏CPU进程和偏I/O进程
3. 实时进程与普通进程

## 进程状态：
1. 运行状态：进程已经占有CPU
2. 就绪状态：具备运行条件但无CPU
3. 阻塞状态：等待某项服务完成或者信号不能运行
   - 浅度阻塞：TASK_INTERRUPTIBLE
   - 深度阻塞：TASK_UNINTERRUPTIBLE
4. 僵死状态
5. 挂起状态

## 进程控制块(Process Control Block)PCB
- 描述进程状态、资源和与相关进程关系的数据结构
- PCB是进程的标志
- 创建进程时创建PCB；进程撤销后销毁PCB

进程=程序+PCB

PCB的基本成员
1. name(ID)
2. status
3. next:下一个PCB指针
4. start_addr：程序地址
5. priority
6. cpu_status：现场保留区（堆栈）
7. comm_info：进程通信
8. process_family
9. own_resource

Linux进程控制块PCB：task_struct
1. 进程状态
2. 调度信息
3. 标识符
4. 内部进程通信信息
5. 链接信息
6. 时间和计时器
7. 文件系统
8. 虚拟内存信息
9. 处理器信息

## 进程切换
进程的上下文：
- 进程运行环境、CPu环境

进程切换过程
- 换入进程的上下文进入CPU（从栈上来）
- 换出进程上下文保存（写入栈中）

## 进程控制
对进程生存期间，对其行为的控制

四个典型行为：
1. 创建进程
2. 阻塞进程
3. 唤醒进程
4. 撤销进程
   
### 进程创建
创建一个具有指定标识的进程

创建进程的过程：
1. 创建一个空白的PCB
2. 获得并赋予进程的ID
3. 为进程分配空间
4. 初始化PCB
5. 出入就绪队列

### 撤销进程
撤销一个指定进程，收回进程所占有的资源，撤销该进程的PCB

进程撤销的时机：
1. 正常结束
2. 异常结束
3. 外界干预

进程撤销的过程：
1. 在PCB队列中检索到PCB
2. 获取该进程的状态
3. 若处于运行态，则终止该进程
4. 释放进程占有资源
5. 从PCB队列中移除

调用void exit(int status)终结进程

进程终结时要释放资源并报告父进程
- 利用status传递进程结束时的状态
- 变为僵尸状态，保留部分PCB信息供wait收集
  - 正常结束还是异常结束
  - 占用总系统CPU时间
  - 缺页中断次数
- 调用schedule()函数，选择新进程运行

### 进程阻塞
停止进程的执行，变为阻塞

进程阻塞的时机
1. 请求系统服务
2. 启动某种操作
3. 新数据尚未到达
4. 无新工作可做

进程阻塞的过程：
1. 停止运行
2. 修改状态
3. 插入合适的队列
4. 调度进程

### 进程唤醒
唤醒处于阻塞队列的某个进程

唤醒的时机：
1. 系统服务满足
2. I/O完成
3. 新数据到达
4. 进程提出新请求

### 进程控制原语
原语：由若干指令构成的具有特定功能

具有原子性

进程控制原语：
1. 创建原语
2. 撤销原语
3. 阻塞原语
4. 唤醒原语

## Linux进程控制
fork函数的实现：do_fork()
```c
int do_fork(){
    struct task_struct *p;
    //分配物理页面存放task_struct结构和内核空间的堆栈
    p = alloc_task_struct();
    //将当前进程task_struct结构中所有内容拷贝到新进程
    *p = *current;
    //判断用户进程数量是否超过最大限制
    if((&p->user->processes)>=p->rlim[RLIMIT])
        goto bad_fork_free;
    //设置子进程为TASK_UNINTERRUPTIBLE
    p->state = TASK_UNINTERRUPTIBLE;
    //拷贝进程的所有信息
    copy_files(clone_flags, p);
    copy_fs(clone_flags, p);
    copy_mm(clone_flags, p);
    //进程创建后与父进程链接起来形成一个进程组
    list_add(&p->thread_group, &current->thread_group);
    //唤醒进程
    wake_up_process(p);
}
```
## 临界资源与临界区
临界资源：一次只允许一个进程独占资源

临界区：进程中访问临界资源的程序段

访问临界区的四个原则：
1. 忙则等待：当临界区忙时，其他进程在临界区外等待
2. 空闲让进：无进程处于临界区，任何有权的进程都有机会进入临界区
3. 有限等待：有限时间内等待
4. 让权等待：等待进程放弃CPU

## 典型调度算法
1. 先来先服务调度：按照进入系统时间来挑选作业。特点：容易实现、效率不高
2. 短作业优先调度：按照运行时间最短优先。长作业等待时间过长
3. 响应比高者优先调度：1+等待时间/运行时间。 
4. 优先数调度算法：根据进程优先级调度（静态优先级与动态优先级）
5. 循环调度算法

## Linux进程调度
### 普通进程
- 采用动态优先级来调度
- 调度程序周期性改变优先级

### 实时进程
- 采用静态优先级来调度
- 由用户预先指定，不会改变

### 调度策略
task_struct->policy指定进程调度策略
```c
#define SCHED_OTHER 0 //普通分时进程，根据动态优先级调度
#define SCHED_FIFO 1 //先进先出策略，实时进程一直占用CPU直至退出、阻塞或者被抢占
#define SCHED_RR 2 //与其他实时进程以轮转的方式共同时使用CPU，确保同优先级的多个进程能共享CPU
``` 

### 调度时机
1. 中断处理过程中直接调度schedule()
2. 中断处理过程返回用户态时根据need_resched标记来调用schedule()
3. 内核线程直接调用schedule()进行进程切换

### 进程切换
- 内核挂起当前CPU上的进程并恢复之间挂起的某个进程
- 任务切换、上下文切换

与中断上下文切换的差别
- 中断前后在同一进程上下文中，只是用户态向内核态执行

进程上下文包含了进程执行所需要的所有信息
- 用户地址空间：包括程序代码、数据、用户堆栈等
- 控制信息：进程描述符、内核堆栈
- 硬件上下文：中断也需要保存硬件上下文，但方法不一样



