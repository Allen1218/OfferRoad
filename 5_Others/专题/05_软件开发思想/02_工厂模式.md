# 1 简单工厂模式
根据传入的参数，获取所需要的对象，无需知道其创建细节

模式结构
1. factory:工厂，负责实现创建所有具体产品类的实例。
2. product:抽象产品，所有具体产品的父类，负责描述所有实例的共有接口
3. concreteProduct：具体产品，继承自抽象产品，一般为多个

优点：
- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例
缺点：
- 工厂类集中了所有产品创建逻辑，一旦不能工作，整个系统受到影响
- 扩展困难，添加新产品需要修改工厂逻辑，违背开闭原则

适用于对象少，逻辑简单的场景

# 02 工厂方法模式
定义一个用户创建对象的接口，让子类决定实例化哪一个类

模式结构：
1. 抽象工厂：声明工厂方法，返回一个产品
2. 具体工厂：实现工厂方法，返回产品实例
3. 抽象产品：定义产品接口
4. 具体产品：实现产品接口

具体产品与具体工厂一一对应

工厂模式的优点：
- 隐藏具体产品实例化细节
- 加入新产品时，无需修改抽象工厂和抽象产品以及客户端，只需要添加具体工厂和具体产品

工厂模式的缺点：
- 添加新产品时，需要增加具体产品类和具体工厂类，增加了系统复杂度

# 抽象工厂模式
一个工厂需要提供多个产品对象，而不是单一的产品对象

模式结构：
1. 抽象工厂：声明生产一系列抽象产品的方法
2. 具体工厂：实现生产一系列抽象产品的方法
3. 抽象产品：定义这一系列产品的声明接口
4. 具体产品：定了具体工厂的具体产品对象，实现产品接口

优点：
- 隔离了具体类的生产
- 保证客户端只使用同一个产品族中的对象
- 新增工具工厂和产品族很方便，满足开闭原则

缺点：
- 新增产品对象时，需要对所有抽象工厂以及其子类进行修改

