# 如何消除隐式转换
使用explicit关键字修饰转移构造函数，防止不必要的隐式转换

# volatile关键字作用
防止编译器进行优化，每次都让程序从内存中去读取数据

# new和malloc的区别
![avrtar][pic_1]

# 引用和指针的区别
指针是一个变量类型，可以不初始化，初始化后可以改变

引用是一个别名，引用必须初始化，且初始化后不可改变

# 异常处理
## 抛出异常
当执行一个throw时，跟在throw后面的语句不再执行。
- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象都将被销毁

## 栈展开
递归地尝试匹配catch子句。在栈展开过程中，退出了某个块，则将在这个块中构建的局部变量进行销毁

## 析构函数与异常
一般来说，析构函数不能抛出自身无法处理的异常，因为异常函数必须正确执行完毕。

## 重新抛出
有时，一个单独的catch语句无法处理某个异常。在执行某些校正操作之后，当前catch将重新抛出传递给另一个catch语句。

## 捕获所有异常的处理代码
```c++
catch(...){

}
```

# 常对象的成员变量是否能够修改
可以修改mutable修饰的成员变量

# 虚函数调用过程
找到对象内存中vptr所指向虚函数表的地址->找到虚函数表对应的虚函数地址。（实际可能是一个jmp指令，为了保护数据，不将地址暴露） 

