# 01 memcpy和memmove的区别
memcpy和memmove都c语言中的库函数，作用都是拷贝一定长度的内存的内容,唯一区别是：当内存空间发生局部重叠时，memmove能够保证拷贝结构是正确的，memcpy不能保证（两个重叠情况，一种能正确，另一种不能正确）
```c
void* memcpy(void* dst, const void* src, size_t count);
void* memmove(void* dst, const void* src, size_t count);
```
重叠情况一：
dst在src前面，均能正确复制

重叠情况二：
src在dst前面，memcpy不能正确复制

下面给出两个函数的实现：
```c
void* my_memcpy(void* dst, const void* src, size_t count){
    char* tmp = (char*)dst;//将void*强转为char*,void*不能直接进行操作
    const char* s_src = (const char*)src;//注意不要丢掉const,虽然不会影响结果，但却是不好的编程习惯
    while(count--){
        *tmp++ = *s_src++;
    }
    return dst;
}

void* my_memmove(void* dst, const void* src, size_t count){
    char* s_dst = dst;
    const char* s_src = (const char*)src;
    if(s_src<s_dst && (s_src + count > s_dst)){//处理第二种重叠情况，反向复制，从而变成第一种重叠情况
        s_dst = s_dst + n - 1;//移动到最后一个位置
        s_src = s_src + n - 1;//移动到最后一个位置
        while(count--){
            *s_dst-- = *s_src--;
        }
        else{
            while(n--){
                *s_dst++ = *s_src++;
            }
        }
        return dst;
    }
}
```
## 02 static关键字作用
可以用来修饰局部变量、全局变量。

修饰局部变量：改变变量生存周期。静态局部变量存在静态区，生命周期为整个程序运行期间

修饰全局变量：改变变量作用域。静态全局变量的作用域仅在当前文件有效，非静态全局变量整个工程都有效

修饰类成员函数：成为静态成员函数。只能访问静态成员变量。

## 03 多态（高频问题）
基类的指针或者引用指向派生类的对象，在调用虚函数时，会根据所指向对象实际的类型决定调用具体的某个虚函数。

优点：提升程序的可扩展性。增加派生类时，只需要按照派生类的特性，重载相应的虚函数，不用修改原始的代码。

实现原理：具有虚函数的类，都会维护一个虚函数表vtable和虚函数指针vptr指向该类的虚函数表，虚函数指针在类的构造函数初始化，指向对应的虚函数表，函数调用时，通过基类指针或者引用找到虚函数指针，根据指针找到对应的虚函数表，然后根据虚函数的声明顺序，确定偏移量，找到对应的虚函数地址。

注意：当要使用多态性质的时候，基类的析构函数需要被定义为虚函数，若基类的析构函数不是虚函数，那么在使用基类的指针或者引用指向派生类时，只会调用基类的析构函数，而不会调用派生类的构造函数，可能导致派生类的资源无法释放导致内存泄漏。

## 03 为什么内联函数，构造函数，静态成员函数不能为虚函数
内联函数：内联函数在编译期展开，而虚函数在运行时绑定，两者矛盾

构造函数：虚函数运行在对象建立基础之上，构造函数调用之前对象还未形成（虚函数指针还未初始化）

静态成员函数：静态成员函数属于一个类而非某个对象，无法根据对象进行判定调用哪个函数。（静态成员函数无需生成对象，直接调用）

