# 01 memcpy和memmove的区别
memcpy和memmove都c语言中的库函数，作用都是拷贝一定长度的内存的内容,唯一区别是：当内存空间发生局部重叠时，memmove能够保证拷贝结构是正确的，memcpy不能保证（两个重叠情况，一种能正确，另一种不能正确）
```c
void* memcpy(void* dst, const void* src, size_t count);
void* memmove(void* dst, const void* src, size_t count);
```
重叠情况一：
dst在src前面，均能正确复制

重叠情况二：
src在dst前面，memcpy不能正确复制

下面给出两个函数的实现：
```c
void* my_memcpy(void* dst, const void* src, size_t count){
    char* tmp = (char*)dst;//将void*强转为char*,void*不能直接进行操作
    const char* s_src = (const char*)src;//注意不要丢掉const,虽然不会影响结果，但却是不好的编程习惯
    while(count--){
        *tmp++ = *s_src++;
    }
    return dst;
}

void* my_memmove(void* dst, const void* src, size_t count){
    char* s_dst = dst;
    const char* s_src = (const char*)src;
    if(s_src<s_dst && (s_src + count > s_dst)){//处理第二种重叠情况，反向复制，从而变成第一种重叠情况
        s_dst = s_dst + n - 1;//移动到最后一个位置
        s_src = s_src + n - 1;//移动到最后一个位置
        while(count--){
            *s_dst-- = *s_src--;
        }
        else{
            while(n--){
                *s_dst++ = *s_src++;
            }
        }
        return dst;
    }
}
```
## 02 static关键字作用
可以用来修饰局部变量、全局变量。

修饰局部变量：改变变量生存周期。静态局部变量存在静态区，生命周期为整个程序运行期间

修饰全局变量：改变变量作用域。静态全局变量的作用域仅在当前文件有效，非静态全局变量整个工程都有效

修饰类成员函数：成为静态成员函数。只能访问静态成员变量。

## 03 多态（高频问题）
基类的指针或者引用指向派生类的对象，在调用虚函数时，会根据所指向对象实际的类型决定调用具体的某个虚函数。

优点：提升程序的可扩展性。增加派生类时，只需要按照派生类的特性，重载相应的虚函数，不用修改原始的代码。

实现原理：具有虚函数的类，都会维护一个虚函数表vtable和虚函数指针vptr指向该类的虚函数表，虚函数指针在类的构造函数初始化，指向对应的虚函数表，函数调用时，通过基类指针或者引用找到虚函数指针，根据指针找到对应的虚函数表，然后根据虚函数的声明顺序，确定偏移量，找到对应的虚函数地址。

注意：当要使用多态性质的时候，基类的析构函数需要被定义为虚函数，若基类的析构函数不是虚函数，那么在使用基类的指针或者引用指向派生类时，只会调用基类的析构函数，而不会调用派生类的构造函数，可能导致派生类的资源无法释放导致内存泄漏。

## 03 为什么内联函数，构造函数，静态成员函数不能为虚函数
内联函数：内联函数在编译期展开，而虚函数在运行时绑定，两者矛盾

构造函数：虚函数运行在对象建立基础之上，构造函数调用之前对象还未形成（虚函数指针还未初始化）

静态成员函数：静态成员函数属于一个类而非某个对象，无法根据对象进行判定调用哪个函数。（静态成员函数无需生成对象，直接调用）

## 04 如何消除隐式转换
使用explicit关键字修饰转移构造函数，防止不必要的隐式转换

## 05 volatile关键字作用
防止编译器进行优化，每次都让程序从内存中去读取数据

## 05 new和malloc的区别
![avrtar][pic_1]

## 06 引用和指针的区别
指针是一个变量类型，可以不初始化，初始化后可以改变

引用是一个别名，引用必须初始化，且初始化后不可改变

## 异常处理
### 抛出异常
当执行一个throw时，跟在throw后面的语句不再执行。
- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象都将被销毁

### 栈展开
递归地尝试匹配catch子句。在栈展开过程中，退出了某个块，则将在这个块中构建的局部变量进行销毁

### 析构函数与异常
一般来说，析构函数不能抛出自身无法处理的异常，因为异常函数必须正确执行完毕。

### 重新抛出
有时，一个单独的catch语句无法处理某个异常。在执行某些校正操作之后，当前catch将重新抛出传递给另一个catch语句。

### 捕获所有异常的处理代码
```c++
catch(...){

}
```

## 常对象的成员变量是否能够修改
可以修改mutable修饰的成员变量

## 虚函数调用过程
找到对象内存中vptr所指向虚函数表的地址->找到虚函数表对应的虚函数地址。（实际可能是一个jmp指令，为了保护数据，不将地址暴露） 

## 什么时候会用到多态，解决什么问题
封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在代码块，都是为了实现代码重用。
代码重用：将一个功能写成一个模块，以便需要相同功能的时候可以直接使用。

多态有两个好处：

1. 不必为每个派生类编写功能调试，只需要对抽象基类进行处理即可。提高程序的可复用性。
2. 派生类的功能可以被基类的指针或引用所调用，提高可扩充性和可维护性。 