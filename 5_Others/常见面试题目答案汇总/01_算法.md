# 01 N个数中第K大的数
首先，该问题存在一个镜像问题，N个数中第（N-k）小的数，选择k和N-K之中较为小的那个进行该问题的解答
### 方法一：对所有元素进行排序，然后取出第K个元素
时间复杂度：O(n*logn)
特点：对全部元素进行排序，K=1时，时间复杂度也为O(n*logn)
### 方法二：只需要对前K个元素排序，不需要对N-K个元素进行排序
思路：使用选择排序或者冒泡排序，进行K次选择，可得到第K大的数
时间复杂度：O(n*k)

*当k很小，或者n-k很小的情况下，该方法很适用*
### 方法三：类快排
思路：随机选取枢纽，得到比枢纽小和比枢纽大两部分，若比枢纽大的部分数量等于K-1，返回当前枢纽；若大于k-1，则在比枢纽大的部分继续查找，重复该过程；若小于k-1，则在比枢纽小部分查找第（K-比枢纽大部分数量 - 1）大的数，重复调用该函数。
时间复杂度：O(N)
缺点：该方法需要将所有数据载入内存，当海量数据时，该方法受限。
### 方法四：小根堆
思路：维护一个大小为K的小根堆，堆顶元素是最大K个数中最小的一个
时间复杂度：O(N*logK)
特点：当海量数据时，内存中可以只维持一个K的堆，若K依然很大，无法载入内存，那么可以将该问题分解先求第m大（m容量的数能够载入内存）的数（需要维持一个额外的计数器，用以统计与第m大的数相等但不在堆中的数目），再求2m大的数。。。最后得到第K大的数
