# 为什么使用Redis
主要从两个方面考虑：**性能**和**并发**
## 性能
在执行耗时很久而且结果不频繁变动的SQL，适合将运行结果放入缓存。Redis是基于内存的缓存，能够使请求迅速从缓存中得到响应，与传统数据库相比，响应速度大幅提高
## 并发
在大并发的情况下，所有的请求直接访问数据库会导致数据库连接异常，需要用Redis做一个缓存操作，并且由于Redis支持高性能的主从复制的集群策略，大大提高满足高并发访问的快速响应。请求优先访问Redis请求数据，从而避免高并发情况下直接访问数据库。

# Redis缺点
## 缓存和数据库双写一致性问题
**强一致性**：任何时刻所有用户或者进程查询到的都是最近一次成功更新的数据。

**最终一致性**：与强一致性相对，在某一时刻用户或者进程查询到的数据可能不同，但最终成功更新的数据都会被用户或者进程查询到

若对数据有强一致性要求，不能放缓存

## 缓存雪崩
**缓存雪崩**：即同一时刻缓存大面积失效，而此时发送来的请求会直接与数据库连接

解决方案：
1. 缓存加上随机的失效时间，避免集体失效
2. 互斥锁：降低吞吐量
3. 双缓存：一级缓存时间短，二级缓存时间长

## 缓存穿透
正常的查询流程为：先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存中。

**多点爆破**：多个缓存中不存在数据

**缓存击穿**：黑客故意请求缓存中不存在的数据，导致所有请求需要与数据库进行查询，导致数据库连接异常

解决方案：
1. 互斥锁：缓存失效时，先去获得锁，然后再去请求数据库
2. 异步更新：无论key是否得到值，都直接返回，value值中维护一个缓存失效时间，如果过期，异步一个线程去读数据库，更新缓存。需要做缓存预热//TODO：没看懂
3. 布隆过滤器：内部维护一系列有效合法的key

## 缓存击穿

**单点爆破**：黑客不断访问一个缓存和数据库中均没有的数据，每次都会访问数据库，然后返回空

用户查询一个不存在的数据，数据库与缓存中均没有，每次查询该数据时，都需要去数据库中查询。

解决方法：为不存在的值设置一个默认值放入缓存中，下一次查询时无需访问数据库

## 缓存并发竞争问题
多个子系统去set同一个key

# Redis为什么这么快
1. 内存操作
2. 单线程操作，避免加锁和上下文切换
3. 采用非阻塞的I/O多路复用机制

# MySQL中有2000w数据，Redis中有20W数据，如何保证Redis中的数据为热点数据
与Redis的六种数据淘汰策略有关：
1. volatile-lru：从已设置过期时间的数据集中选择最近很少使用的数据
2. volatile-ttl：从已设置过期时间的数据集中选择将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中随机选择数据淘汰
4. allkeys-lru：从所有数据集中选择最近很少使用的数据淘汰
5. allkeys-random：从数据集中随机选择数据淘汰
6. no-enviction：禁止驱逐数据

**使用策略规则**：
- 如果数据呈现幂律分布，一部分数据访问频率高，一部分数据访问频率高，一部分访问频率低，使用allkeys-lru
- 如果数据访问频率大致相等，则使用allkeys-random




