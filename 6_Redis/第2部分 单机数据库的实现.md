# 第二部分单机数据库的实现

## 第9章 数据库

### 服务器中的数据库
Redis服务器将所有数据库保存在服务器状态redis.h/redisServer结构中
```c
struct redisServer{
    //...
    redisDb *db;//保存服务器中所有数据库的数组
    int dbnum;//服务器数据库数量
    //...
}
```
切换数据库操作则是通过改变redisClient中db指针所指向的数据库实现的

### 数据库键空间
Redis是一个键值对数据库服务器。每个数据库都由一个redis.h/redisDb结构表示
```c
typedef struct redisDb{
    //...
    dict* dict;//数据库键空间，保存数据库中所有键值对
    //...
}redisDb;
```
### 读写键空间的维护操作
- 在读取一个键后（读写操作均需要对键进行读取），服务器会根据键是否存在，来更新服务器的建空间命中（hit）和不命中（miss）次数
- 在读取一个键之后，更新键的LRU时间
- 若服务器读取一个键时，发现该键已经过期，那么服务器会删除该键，然后执行余下操作
- 若客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改后，会将该键标记为脏(dirty)，从而让事务程序注意到这个键被修改
- 服务器每修改一个键，都将脏(dirty)键计数器加1，这个计数器会触发服务器持久化以及复制操作
- 若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按照配置发送相应的数据库通知

## 键的生存时间或者过期时间
设置过期时间
- EXPIRE<key><ttl>将键key的生存时间设置为ttl秒
- PEXPIRE<key><ttl>将键key的生存时间设置为ttl毫秒
- EXPIREAT<key><timestamp>将key的过期时间设为timestamp所指定的秒数时间戳
- PEXPIREAT<key><timestamp>将key的过期时间设为timestamp所指定的毫秒数时间戳

### 保存过期时间
```c
typedef struct redisDb{
    //...
    dict* expires;//过期字典
    //...
}redisDb;
```

### 过期键删除策略
三种策略：
1. 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键过期时间来删除键
2. 惰性删除：只有当从键空间中获取键时，检测该键是否过期，过期则删除
3. 定期删除：每隔一段时间，程序对数据库进行一次检查，删除一定数量的过期键

Redis采用惰性删除与定期删除相结合的方式

定期删除策略：
- 从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
- 全局变量current_db记录当前检查进度，并在下一次检查时，接着上一次的进度进行处理

### AOF、RDB和复制功能对过期键的处理
1. 生成RDB文件时，忽略过期键
2. 载入RDB文件时，主服务器模式下忽略过期键，从服务器模式载入过期键
3. AOF写入时，过期键也会被写入，在删除时，追加删除命令
4. AOF重写时，忽略过期键
5. 当服务器运行在复制模式下时，从服务器在执行客户端发送的读命令时，即使碰到过期键也不删除，而是返回给客户端，只有当客户端向主服务器发送读命令，主服务器删除过期键，并发送DEL命令给从服务器，从服务器才删除该过期键

### 数据库通知

# 第十章 RDB持久化
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。RDB文件是一个经过压缩的二进制文件

## RDB文件的创建和载入
RDB文件的的生成命令：
- SAVE:阻塞Redis服务器进程，直到RDB文件创建完毕为止
- BGSAVE:派生出一个子进程，然后子进程负责创建RDB文件，服务器继续处理命令请求

RDB文件的载入是在服务器启动时自动运行的，没有专门用于载入RDB文件的命令

AOF文件的更新频率比RDB文件的更新频率高，所以优先使用AOF持久化功能

BGSAVE命令执行时，Redis服务器依然能够处理客户端命令请求。但在处理SAVE BGSAVE BGREWRITEAOF命令会有所不同
- SAVE：拒绝
- BGSAVE:拒绝
- BGREWRITEAOF：延迟

## 自动间隔性保存
默认配置
```c
save 900 1;//900s内修改1次
save 300 10;//300s内修改10次
save 60 10000;//60s内修改10000次
```
可以修改默认配置

## dirty计数器和lastsave属性
- dirty计数器：记录上一次SAVE或者BGSAVE命令成功运行后，服务器对数据库状态进行了多少次修改
- lastsave：记录服务器上一次成功执行SAVE命令或者BGSAVE命令的时间
  
## RDB文件结构
REDIS | db_version | databases | EOF | check_sum
- REDIS:五个字节的字符
- db_version:四个字节
- databases：最少0字节
- EOF：1字节的常量
- check_sum:8个字节

### databases部分
SELECTDB | db_number | key_value_pairs
- SELECTDB：1字节的常量
- db_number：数据库下标
- key_value_pairs:键值对

key_value_pairs包括三部分：
1. TYPE：1字节的常量
2. key：字符串对象
3. value：TYPE所指类型的对象

### value的编码
1. **字符串对象**：TYPE的值为REDIS_RDB_TYPE_STRING，字符串对象的编码可以是REDIS_ENCODING_INT REDIS_ENCODING_RAW 或者 REDIS_ENCODING_EMBSTR。REDIS_ENCODING_INT又可以分为REDIS_RDB_ENC_INT8 ~_INT16 和 ~_INT32三个常量中的一个；REDIS_ENCODING_RAW根据字符串长度是否大于20字节来决定是否压缩（大于压缩）。压缩后的结构为 REDIS_RDB_ENC_LZF | compressed_len | orgin_len | compressed_string 
2. **列表对象**：TYPE值为REDIS_RDB_TYPE_LIST，那么保存一个REDIS_ENCODING_LINKEDLIST编码的列表对象，其结构为list_length | item1 | item2 | ... | itemN
3. **集合对象**：TYPE值为REDIS_RDB_TYPE_SET，那么保存一个REDIS_ENCODING_HT编码的对象，其结构为set_size | elem1 | elem2 | ... | elemN
4. **哈希表对象**：TYPE值为REDIS_RDB_TYPE_HASH，那么保存一个REDIS_ENCODING_HT编码的对象，其结构为hash_size | key_value_pair1 | key_value_pair2 | ... | key_value_pairN
5. **有序集合**：TYPE值为REDIS_RDB_TYPE_ZSET，那么保存一个REDIS_ENCODING_SKIPLIST编码的对象，其结构为sort_set_size | elem1 | elem2 | ... | elemN
6. **INTSET**：TYPE值为REDIS_RDB_TYPE_INTSET，那么保存一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，再保存到文件中
7. **ZIPLIST**：TYPE值为REDIS_RDB_TYPE_LIST_ZIPLIST REDIS_RDB_TYPE_HASH_ZIPLIST REDIS_RDB_TYPE_ZSET_ZIPLIST，那么保存的就是一个压缩列表的对象，RDB文件保存的方法是将压缩列表转换为字符串对象，然后保存到文件中，读取时，读入字符串对象，并根据TYPE的值，转换为原来的压缩列表对象
   
# 第11章 AOF持久化
AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的

## AOF持久化的实现
- 命令追加
- 文件写入
- 文件同步

### 命令追加
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令时，追加到服务器状态的aof_buf缓冲区的末尾
```c
struct redisServer{
    //```
    sds aof_buf;
    //```
};
```
### 文件写入和同步
Redis服务器进程是一个事件循环，在每个事件循环周期调用flushAppendOnlyFile函数，考虑是否将aof_buf写入和保存到AOF文件中
appendfsync | flushAppendOnlyFile 
----------- | -------------------
always      | 总是将aof_buf缓冲区的内容写入并同步到AOF文件，最安全最慢
everysec    | 总是将aof_buf缓冲区的内容写入，每隔1秒同步AOF文件(刷到磁盘)
no          | 总是将aof_buf缓冲区的内容写入，但不进行同步，何时同步由操作系统决定

### AOF的载入和数据还原
1. 创建一个不带网络连接的伪客户端
2. 从AOF文件中读取并分析一条写命令
3. 使用伪客户端执行该命令
4. 重复2和3步骤，直到所有命令执行完毕

## AOF文件重写
AOF文件不断新增写命令，随着时间的流逝，文件越来越大，则需要进行AOF文件重写来去掉其中的冗余命令。
### AOF文件重写实现
遍历数据库中所有键值对，添加对应命令。

AOF文件重写涉及大量的IO操作，需要在子进程中进行，可以达到两个目的：
1. 子进程进行AOF重写期间，服务器进程可以继续处理命令请求
2. 子进程拥有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁

AOF重写期间，服务器可能也进行了写操作，造成子进程与父进程的数据不一致，Redis服务器设置了一个AOF重写缓冲区。

AOF重写期间，服务器进程执行三个工作：
1. 执行客户端发来的命令
2. 将执行的写命令追加到AOF缓冲区
3. 将执行的写命令追加到AOF重写缓冲区

# 第12章 事件
Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
1. 文件事件：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象
2. 时间事件：Redis服务器需要在给定时间点执行

## 文件事件
Redis基于Reactor模式的网络时间处理器：这个处理器被称为文件事件处理器：
1. 文件事件处理器采用I/O多路复用来同时监听多个套接字，并根据套接字目前所执行的任务来为套接字关联不同的事件处理器
2. 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相关的文件事件就会产生

### 文件事件处理器的构成
文件事件处理器的四个部分：
1. 套接字
2. I/O多路复用
3. 文件事件分派器
4. 事件处理器

IO多路复用实现通过select epoll evport kqueue来实现（效率高到低：evport epoll kqueue select)

### 文件事件处理器
- 连接应答处理器：connect函数连接服务器监听套接字时，套接字产生AE_READABLE事件，引发连接应答处理器执行
- 命令请求处理器：连接成功后，套接字的AE_READABLE事件与命令请求处理器关联，当客户端发送命令请求时，套接字产生AE_READABLE事件，引发执行命令请求处理器执行
- 命令回复处理器：当服务器有命令回复需要传送给客户端时，服务器会将客户端套接字的AE_WRITEABLE关联，引发回复处理器执行，发送完毕后，解除命令回复处理器与客户端套接字的AE_WRITEABLE的关联
- 复制处理器

## 时间事件
1. 定时时间：指定时间执行一次（时间事件处理器返回AE_NOMORE)
2. 周期性时间：每隔一段时间执行一次（时间事件处理器返回非AE_NOMORE的整数值，为下一次事件到达的时间间隔）

时间事件三个属性：
1. id：服务器为时间事件创建的全局唯一ID（递增）
2. when：毫秒级精度的UNIX时间戳
3. timeProc：时间事件处理器

时间事件被放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，查找已到达时间事件。正常模式下，Redis服务器只使用serverCron一个时间事件，而benchmark模式下，也只使用两个时间事件。所以不影响性能

### 时间事件应用实例：serverCron函数
Redis服务器需要定期对自身资源和状态进行检查和调整，主要包括：
1. 更新服务器的各类统计数据，比如时间、内存占用、数据库占用等
2. 清理数据库中的过期键值对
3. 关闭和清理连接失效的客户端
4. 尝试进行AOF或RDB持久化操作
5. 若服务器为主服务器，对从服务器进行定期同步
6. 若处于集群模式，对集群进行定期同步和连接测试

默认秒执行10次

## 事件的调度与执行
服务器中同时存在文件事件和时间事件两种类型，需要对两种时间进行调度，决定何时处理文件事件，何时处理时间事件以及花多少时间来处理它们等等

事件的调度和执行规则如下：
```python
def aeProcessEvent():
    time_event = aeSearchNearestTimer()#获取到达时间离当前时间最接近的时间事件
    remaind_ms = time_event.when - unix_ts_now()#计算最接近时间事件距离到达还有多少毫秒
    if remaind_ms < 0:
        remaind_ms = 0
    timeval = create_timeval_with_ms(remaind_ms)#根据剩余毫秒数创建timeval结构
    aeApiPoll(timeval)#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
    processFileEvents()
    processTimeEvents()
```

 
# 第13章 客户端
Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接。Redis通过使用多路IO复用技术实现文件事件处理器。

## 客户端属性
客户端属性可以分为两类：
1. 通用属性：无论客户端执行什么工作，都需要的属性
2. 与特定功能相关的属性

- 套接字描述符：套接字描述符为-1时表示伪客户端，普通客户端的套接字描述符为大于-1的整数
- 名字：默认情况下名字为空
- 标志：记录了客户端的角色
    - REDIS_MASTER:主服务器
    - REDIS_SLAVE:从服务器
    - REDIS_PRE_PSYNC:低于Redis2.8的从服务器，不能使用PSYNC命令
    - REDIS_LUA_CLIENT:专门处理Lua脚本的伪客户端
    - REDIS_MONITOR:正在执行MONITOR命令
    - REDIS_UNIX_SOCKET:使用UNIX套接字
    - REDIS_BLOCKED:正在被BRPOP BLPOP等命令阻塞
    - REDIS_UNBLOCKED:从REDIS_BLOCKED标志所表示的阻塞状态脱离开
    - REDIS_MULTI:正在执行事务
    - REDIS_DIRTY_CAPS:使用WATCH命令监视的数据库键已经被修改
    - REDIS_CLOSE_ASAP:输出缓冲区大小超出了服务器允许的范围
    - REDIS_CLOSE_AFTER_REPLY:表示用户对客户端执行了CLIENT KILL命令或者客户端发送给服务器的命令请求包含了错误的协议类容
    - REDIS_ASKING:客户端向集群节点发送了ASKING命令
    - REDIS_FORCE_AOF:强制服务器将当前正在执行的命令写入到AOF文件。执行PUBSUB命令会打开该标志
    - REDIS_FORCE_REPL:强制主服务器将当前执行的命令复制给所有从服务器。执行SCRIPT LOAD会打开该标志和REDIS_FORCE_AOF标志
    - 在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送该命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY标志

    典型标志组合
    ```c
    REDIS_MASTER;//客户端是一个主服务器

    REDIS_BLOCKED;//客户端正被列表命令阻塞

    REDIS_MULTI | REDIS_DIRTY_CAS;//客户端正在执行事务，但事务的安全性已经被破坏

    REDIS_SLAVE | REDIS_PRE_PSYNC;//客户端是一个从服务器，并且版本低于redis 2.8

    REDIS_LUA_CLIENT | REDIS_FORCE_AOF | REDIS_FORCE_REPL;//专门用于执行lua脚本包含的Redis命令的伪客户端，并强制服务器将当前执行的命令写入AOF文件，并复制给从服务器
    ```
- 输入缓冲区：用于保存客户端发送的命令请求，根据输入内容动态地扩大或缩小，最大不能超过1GB，否则将关闭客户端
- 命令与命令参数：对命令请求的内容进行分析，将得到的命令参数与命令参数的个数分别保存到客户端状态的argv和argc属性
- 命令的实现函数：根据argv[0]的值，在命令表中查找对应的命令实现函数
- 输出缓冲区：执行命令所得到的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端存在两个输出缓冲区，一个缓冲区大小是固定的，另一个缓冲区大小是可变的
  - 固定大小的缓冲区用于保存那些长度比较短的回复，默认16KB
  - 可变大小的缓冲区用于保存那些长度比较大的回复
- 身份验证：客户端的authenticated属性用于记录客户端是否通过了身份验证，0表示未通过，1表示通过
- 时间：
    ```c
    typedef struct redisClient{
        //...
        time_t ctime;//客户端创建时间
        time_t lastinteraction;//客户端与服务器最后一次进行互动的时间，可用于计算空转时长
        time_t obuf_soft_limit_reached_time;//记录了输出缓冲区第一次达到软性限制的时间
        //...
    }
    ```
## 客户端的创建与关闭
### 创建普通客户端
若客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端调用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾

### 关闭普通客户端
普通客户端可能因为多种原因被关闭：
1. 客户端进程退出或被杀死
2. 客户端向服务器发送了带有不符合协议格式的命令请求
3. 调用CLIENT KILL命令会关闭目标客户端
4. 若用户为服务器设置了timeout属性，那么当客户端空转时间超过了timeout选项设置的值时，客户端将被关闭
5. 客户端发送的命令请求超过了输入缓冲区的限制代销（默认为1GB）
6. 要发送给客户端的命令回复超过了输出缓冲区的限制大小

前面提到一个客户端会有两个输出缓冲区，一个固定长度输出缓冲区，一个可变长度的输出缓冲区，理论上可变长度的缓冲区可以保存任意长的命令回复。但为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区大小，并在缓冲区大小超过范围时，执行相应的操作，服务器采用两种模式来限制客户端输出缓冲区的大小：
- 硬性限制(hard limit)：如果输出缓冲区超过硬性限制所设置的大小，则立即关闭客户端
- 软性限制(soft limit)：输出缓冲区超过了软性限制所设置的大小，那么使用obuf_soft_limit_reached_time记下开始超过软性限制时间，当超过系统设置的时长时关闭客户端

### Lua脚本伪客户端
服务器会在初始化时创建负责执行Lua脚本中包含Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中，lua_client伪客户端在服务器运行的整个生命期中会一直存在

### AOF文件的伪客户端
在载入AOF文件时，创建用于执行AOF文件包含的Redis命令的伪客户端，在载入完成之后，关闭这个伪客户端

## 重点回顾
- 服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表末尾
- 客户端状态的flags属性使用不同的标志位来表示客户端的角色，以及客户端当前所处的状态
- 输入缓冲区记录了客户端发送的命令请求，这个缓冲区大小默认为1GB
- 命令的参数和参数个数会被记录到客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数
- 客户端有固定大小缓冲区和可变大小缓冲区，其中固定大小缓冲区最大为16KB，而可变大小不能超过服务器设置的硬性限制的值，或者长时间超过软性限制，否则会被服务端关闭
- 客户端通过网络连接上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送不合协议的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输入输出缓冲区大小超过限制等原因都会关闭客户端
- 处理Lua脚本的伪客户端随服务器一直存在
- 载入AOF文件的伪客户端只有在载入时创建，载入完毕后关闭

# 第14章 服务器
Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的的数据，并通过资源管理来维持服务器自身的运转。

## 命令请求的执行过程
如果使用客户端执行以下命令：
```redis
redis>SET KEY VALUE
OK
```
那么从客户端发送SET KEY VALUE到获得回复OK期间，客户端和服务器共需要执行以下操作：
1. 客户端向服务器发送命令请求SET KEY VALUE
2. 服务器接收并处理客户端发送来的命令请求，并在数据库中进行设置操作，然后产生命令回复OK
3. 服务器将命令回复OK发送给客户端
4. 客户端接收服务器的命令回复，打印OK

### 命令执行器（1）：查找命令实现
命令执行器根据客户端状态argv[0]参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里。

命令表是一个字典，键为命令名字，值为redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息

### 命令执行器（2）：执行预备操作
- 检查客户端状态的cmd指针是否为NULL
- 检查客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求的参数个数是否正确
- 检查客户端是否通过了身份验证
- 如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收
- 如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，那么服务器拒绝执行写命令
- 如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBCRIBE命令订阅模式，那么服务器只会执行客户端发送来的SUBSCRIBE PSUBSCRIBE UNSUBSCRIBE UNPSUBSCRIBE命令，其他命令都会被拒绝
- 如果服务器正在进行数据载入，那么客户端发送命令必须带有l标识
- 如果服务器因执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发送来的SHUTDOWN nosave命令和SCRIPT KILL命令
- 如果服务器正在执行事务，那么服务器只会执行EXEC DISCARD MULTI WATCH四个命令
- 如果服务器打开了监视器功能，那么服务器会将执行的命令和参数等信息发送给监视器

### 命令执行器（3）：调用命令的实现函数
```c
client->cmd->proc(client);
```
### 命令执行器（4）：执行后续工作
1. 若服务器开启了慢查询日志功能，会检查是否需要将请求添加至日志
2. 根据刚刚执行命令消耗的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的call计数器的值增加一
3. 如果服务器开启了AOF持久化功能，会根据持久化配置选择是否将刚刚执行的命令请求写入到AOF缓冲区里面
4. 如果其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器

## serverCron函数
Redis服务器的serverCron函数默认每隔100毫秒执行一次，该函数负责管理服务器的资源，并保持服务器良好运转。

- 更新服务器时间缓存：Redis服务器中不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为减少系统调用的执行次数，服务器状态的unixtime属性和mstime属性被用作当前时间缓存。因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以精度不高，只有在打印日志、更新服务器的LRU时钟、决定是否持久化任务、计算服务器上线时间这类对时间精度要求不高的功能上使用
- 更新LRU时钟
- 更新服务器每秒执行命令次数：serverCron函数中的trackOperationsPerSecond以每100毫秒一次的频率执行，以抽样计算的方式，估算并记录服务器在最近一秒处理的命令请求数量
- 更新服务器内存峰值记录
- 处理SIGTERM信号:关联处理器sigtermHandler函数，打开服务器状态shutdown_asap标识，并根据属性的值决定是否关闭服务器
- 管理客户端资源：若客户端与服务器之间的连接已经超时，释放该客户端；如果上一次请求之后，输入缓冲区大小超过一定长度，释放客户端当前缓冲区，并重新创建一个默认大小的输入缓冲区
- 管理数据库资源：对一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作
- 执行被延迟的BGREWRITEAOF:在执行BGSAVE命令期间，BGREWRITEAOF命令会被延迟
- 检查持久化操作的运行状态：服务器状态使用rdb_child_pid和aof_child_pid属性记录执行BGSAVE和BGREWRITEAOF命令的子进程ID，该ID用于检查以上两个命令的执行状态
- 将AOF缓冲区的内容写入AOF文件：若开启了AOF持久化功能，并且缓冲区中还有待写入的数据，那么会调用相应程序，将AOF缓冲区写入AOF文件
- 关闭异步客户端：关闭输出缓冲区大小超出限制的客户端
- 增加cronloops计数器的值

## 初始化服务器
一个Redis服务器从启动到接收客户端的请求，需要经过一系列的初始化和设置过程
### 初始化服务器状态结构
初始化server变量的工作由redis.c/initServerConfig函数完成：
```c
void initServerConfig(void){
    getRandomHexChars(server.runid, REDIS_RUN_ID_SIZE);//设置运行id
    server.runid[REDIS_RUN_ID_SIZE] = '\0';
    server.configfile = NULL;//默认配置文件路径
    server.hz = REDIS_DEFAULT_HZ;//默认服务器频率
    server.arch_bits = (sizeof(long) == 8) ?  64 : 32;//设置服务器运行架构
    server.port = REDIS_SERVERPORT;//设置默认服务器端口号
    //...
}
```
### 载入配置选项
### 初始化服务器数据结构
- server.clients链表
- server.db数组
- 保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表
- 用于执行Lua脚本的Lua环境server.lua
- 用于保存慢查询日志的server.slowlog

### 还原数据库状态
载入RDB文件或者AOF文件还原数据状态

### 执行事件循环

## 重点回顾
- 命令请求主要步骤：
  1. 客户端发送命令给服务器
  2. 服务器读取命令请求，并分析命令参数
  3. 命令执行器根据参数查找命令的实现函数，执行函数并得到命令回复
  4. 服务器将命令回复返回给客户端
- serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态、处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等
- 服务器从启动到处理客户端的命令请求需要执行以下步骤：
  1. 初始化服务器状态
  2. 载入服务器配置
  3. 初始化服务器数据结构
  4. 还原数据库状态
  5. 执行事件循环

## 重点回顾
- Redis服务器是一个时间驱动程序，服务器处理的事件分为时间事件和文件事件两类
- 文件事件处理器是基于Reactor模式实现的网络通信程序
- 文件事件是对套接字操作的抽象：每次套接字变为可应答(acceptable)、可写(writable)或者可读(readable)时，相应的文件事件就会产生
- 文件事件分为AE_READABLE事件和AE_WRITABLE事件两类
- 时间事件分为定时事件和周期事件
- 服务器一般只有serverCron函数一个时间事件
- 文件事件和时间事件之间是合作关系，服务器会轮流处理两种事件，并不会进行抢占
- 时间事件的实际处理时间通常会比设定的晚一些
  