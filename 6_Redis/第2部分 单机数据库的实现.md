# 第二部分单机数据库的实现

## 第9章 数据库

### 服务器中的数据库
Redis服务器将所有数据库保存在服务器状态redis.h/redisServer结构中
```c
struct redisServer{
    //...
    redisDb *db;//保存服务器中所有数据库的数组
    int dbnum;//服务器数据库数量
    //...
}
```
切换数据库操作则是通过改变redisClient中db指针所指向的数据库实现的

### 数据库键空间
Redis是一个键值对数据库服务器。每个数据库都由一个redis.h/redisDb结构表示
```c
typedef struct redisDb{
    //...
    dict* dict;//数据库键空间，保存数据库中所有键值对
    //...
}redisDb;
```
### 读写键空间的维护操作
- 在读取一个键后（读写操作均需要对键进行读取），服务器会根据键是否存在，来更新服务器的建空间命中（hit）和不命中（miss）次数
- 在读取一个键之后，更新键的LRU时间
- 若服务器读取一个键时，发现该键已经过期，那么服务器会删除该键，然后执行余下操作
- 若客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改后，会将该键标记为脏(dirty)，从而让事务程序注意到这个键被修改
- 服务器每修改一个键，都将脏(dirty)键计数器加1，这个计数器会触发服务器持久化以及复制操作
- 若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按照配置发送相应的数据库通知

## 键的生存时间或者过期时间
设置过期时间
- EXPIRE<key><ttl>将键key的生存时间设置为ttl秒
- PEXPIRE<key><ttl>将键key的生存时间设置为ttl毫秒
- EXPIREAT<key><timestamp>将key的过期时间设为timestamp所指定的秒数时间戳
- PEXPIREAT<key><timestamp>将key的过期时间设为timestamp所指定的毫秒数时间戳

### 保存过期时间
```c
typedef struct redisDb{
    //...
    dict* expires;//过期字典
    //...
}redisDb;
```

### 过期键删除策略
三种策略：
1. 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键过期时间来删除键
2. 惰性删除：只有当从键空间中获取键时，检测该键是否过期，过期则删除
3. 定期删除：每隔一段时间，程序对数据库进行一次检查，删除一定数量的过期键

Redis采用惰性删除与定期删除相结合的方式

定期删除策略：
- 从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
- 全局变量current_db记录当前检查进度，并在下一次检查时，接着上一次的进度进行处理

### AOF、RDB和复制功能对过期键的处理
1. 生成RDB文件时，忽略过期键
2. 载入RDB文件时，主服务器模式下忽略过期键，从服务器模式载入过期键
3. AOF写入时，过期键也会被写入，在删除时，追加删除命令
4. AOF重写时，忽略过期键
5. 当服务器运行在复制模式下时，从服务器在执行客户端发送的读命令时，即使碰到过期键也不删除，而是返回给客户端，只有当客户端向主服务器发送读命令，主服务器删除过期键，并发送DEL命令给从服务器，从服务器才删除该过期键

### 数据库通知

# 第十章 RDB持久化
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。RDB文件是一个经过压缩的二进制文件

## RDB文件的创建和载入
RDB文件的的生成命令：
- SAVE:阻塞Redis服务器进程，直到RDB文件创建完毕为止
- BGSAVE:派生出一个子进程，然后子进程负责创建RDB文件，服务器继续处理命令请求

RDB文件的载入是在服务器启动时自动运行的，没有专门用于载入RDB文件的命令

AOF文件的更新频率比RDB文件的更新频率高，所以优先使用AOF持久化功能

BGSAVE命令执行时，Redis服务器依然能够处理客户端命令请求。但在处理SAVE BGSAVE BGREWRITEAOF命令会有所不同
- SAVE：拒绝
- BGSAVE:拒绝
- BGREWRITEAOF：延迟

## 自动间隔性保存
默认配置
```c
save 900 1;//900s内修改1次
save 300 10;//300s内修改10次
save 60 10000;//60s内修改10000次
```
可以修改默认配置

## dirty计数器和lastsave属性
- dirty计数器：记录上一次SAVE或者BGSAVE命令成功运行后，服务器对数据库状态进行了多少次修改
- lastsave：记录服务器上一次成功执行SAVE命令或者BGSAVE命令的时间
  
## RDB文件结构
REDIS | db_version | databases | EOF | check_sum
- REDIS:五个字节的字符
- db_version:四个字节
- databases：最少0字节
- EOF：1字节的常量
- check_sum:8个字节

### databases部分
SELECTDB | db_number | key_value_pairs
- SELECTDB：1字节的常量
- db_number：数据库下标
- key_value_pairs:键值对

key_value_pairs包括三部分：
1. TYPE：1字节的常量
2. key：字符串对象
3. value：TYPE所指类型的对象

### value的编码
1. **字符串对象**：TYPE的值为REDIS_RDB_TYPE_STRING，字符串对象的编码可以是REDIS_ENCODING_INT REDIS_ENCODING_RAW 或者 REDIS_ENCODING_EMBSTR。REDIS_ENCODING_INT又可以分为REDIS_RDB_ENC_INT8 ~_INT16 和 ~_INT32三个常量中的一个；REDIS_ENCODING_RAW根据字符串长度是否大于20字节来决定是否压缩（大于压缩）。压缩后的结构为 REDIS_RDB_ENC_LZF | compressed_len | orgin_len | compressed_string 
2. **列表对象**：TYPE值为REDIS_RDB_TYPE_LIST，那么保存一个REDIS_ENCODING_LINKEDLIST编码的列表对象，其结构为list_length | item1 | item2 | ... | itemN
3. **集合对象**：TYPE值为REDIS_RDB_TYPE_SET，那么保存一个REDIS_ENCODING_HT编码的对象，其结构为set_size | elem1 | elem2 | ... | elemN
4. **哈希表对象**：TYPE值为REDIS_RDB_TYPE_HASH，那么保存一个REDIS_ENCODING_HT编码的对象，其结构为hash_size | key_value_pair1 | key_value_pair2 | ... | key_value_pairN
5. **有序集合**：TYPE值为REDIS_RDB_TYPE_ZSET，那么保存一个REDIS_ENCODING_SKIPLIST编码的对象，其结构为sort_set_size | elem1 | elem2 | ... | elemN
6. **INTSET**：TYPE值为REDIS_RDB_TYPE_INTSET，那么保存一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，再保存到文件中
7. **ZIPLIST**：TYPE值为REDIS_RDB_TYPE_LIST_ZIPLIST REDIS_RDB_TYPE_HASH_ZIPLIST REDIS_RDB_TYPE_ZSET_ZIPLIST，那么保存的就是一个压缩列表的对象，RDB文件保存的方法是将压缩列表转换为字符串对象，然后保存到文件中，读取时，读入字符串对象，并根据TYPE的值，转换为原来的压缩列表对象
   
# 第11章 AOF持久化
AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的

## AOF持久化的实现
- 命令追加
- 文件写入
- 文件同步

### 命令追加
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令时，追加到服务器状态的aof_buf缓冲区的末尾
```c
struct redisServer{
    //```
    sds aof_buf;
    //```
};
```
### 文件写入和同步
Redis服务器进程是一个事件循环，在每个事件循环周期调用flushAppendOnlyFile函数，考虑是否将aof_buf写入和保存到AOF文件中
appendfsync | flushAppendOnlyFile 
----------- | -------------------
always      | 总是将aof_buf缓冲区的内容写入并同步到AOF文件，最安全最慢
everysec    | 总是将aof_buf缓冲区的内容写入，每隔1秒同步AOF文件(刷到磁盘)
no          | 总是将aof_buf缓冲区的内容写入，但不进行同步，何时同步由操作系统决定

### AOF的载入和数据还原
1. 创建一个不带网络连接的伪客户端
2. 从AOF文件中读取并分析一条写命令
3. 使用伪客户端执行该命令
4. 重复2和3步骤，直到所有命令执行完毕

## AOF文件重写
AOF文件不断新增写命令，随着时间的流逝，文件越来越大，则需要进行AOF文件重写来去掉其中的冗余命令。
### AOF文件重写实现
遍历数据库中所有键值对，添加对应命令。

AOF文件重写涉及大量的IO操作，需要在子进程中进行，可以达到两个目的：
1. 子进程进行AOF重写期间，服务器进程可以继续处理命令请求
2. 子进程拥有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁

AOF重写期间，服务器可能也进行了写操作，造成子进程与父进程的数据不一致，Redis服务器设置了一个AOF重写缓冲区。

AOF重写期间，服务器进程执行三个工作：
1. 执行客户端发来的命令
2. 将执行的写命令追加到AOF缓冲区
3. 将执行的写命令追加到AOF重写缓冲区

# 第12章 事件
Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
1. 文件时间：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象
2. 时间事件：Redis服务器需要在给定时间点执行

## 文件事件
Redis基于Reactor模式的网络时间处理器：这个处理器被称为文件事件处理器：
1. 文件事件处理器采用IO多路复用来同时监听多个套接字，并根据套接字目前所执行的任务来为套接字关联不同的事件处理器
2. 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相关的文件事件就会产生

### 文件事件处理器的构成
文件事件处理器的四个部分：
1. 套接字
2. IO多路复用
3. 文件事件分派器
4. 事件处理器

IO多路复用实现通过select epoll evport kqueue来实现（效率高到低：evport epoll kqueue select)

### 文件事件处理器
- 连接应答处理器：connect函数连接服务器监听套接字时，套接字产生AE_READABLE事件，引发连接应答处理器执行
- 命令请求处理器：连接成功后，套接字的AE_READABLE事件与命令请求处理器关联，当客户端发送命令请求时，套接字产生AE_READABLE事件，引发执行命令请求处理器执行
- 命令回复处理器：当服务器有命令回复需要传送给客户端时，服务器会将客户端套接字的AE_WRITEABLE关联，引发回复处理器执行，发送完毕后，解除命令回复处理器与客户端套接字的AE_WRITEABLE的关联
- 复制处理器

## 时间事件
1. 定时时间：指定时间执行一次（时间事件处理器返回AE_NOMORE)
2. 周期性时间：每隔一段时间执行一次（时间事件处理器返回非AE_NOMORE的整数值，为下一次事件到达的时间间隔）

时间事件三个属性：
1. id：服务器为时间事件创建的全局唯一ID（递增）
2. when：毫秒级精度的UNIX时间戳
3. timeProc：时间事件处理器

时间事件被放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，查找已到达时间事件。正常模式下，Redis服务器只使用serverCron一个时间事件，而benchmark模式下，也只使用两个时间事件。所以不影响性能

### 时间事件应用实例：serverCron函数
Redis服务器需要定期对自身资源和状态进行检查和调整，主要包括：
1. 更新服务器的各类统计数据，比如时间、内存占用、数据库占用等
2. 清理数据库中的过期键值对
3. 关闭和清理连接失效的客户端
4. 尝试进行AOF或RDB持久化操作
5. 若服务器为主服务器，对从服务器进行定期同步
6. 若处于集群模式，对集群进行定期同步和连接测试

默认秒执行10次

## 事件的调度与执行
服务器中同时存在文件事件和时间事件两种类型，需要对两种时间进行调度，决定何时处理文件事件，何时处理时间事件以及花多少时间来处理它们等等

事件的调度和执行规则如下：
```python
def aeProcessEvent():
    time_event = aeSearchNearestTimer()#获取到达时间离当前时间最接近的时间事件
    remaind_ms = time_event.when - unix_ts_now()#计算最接近时间事件距离到达还有多少毫秒
    if remaind_ms < 0:
        remaind_ms = 0
    timeval = create_timeval_with_ms(remaind_ms)#根据剩余毫秒数创建timeval结构
    aeApiPoll(timeval)#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
    processFileEvents()
    processTimeEvents()
```
## 重点回顾
- Redis服务器是一个时间驱动程序，服务器处理的事件分为时间事件和文件事件两类
- 文件事件处理器是基于Reactor模式实现的网络通信程序
- 文件事件是对套接字操作的抽象：每次套接字变为可应答(acceptable)、可写(writable)或者可读(readable)时，相应的文件事件就会产生
- 文件事件分为AE_READABLE事件和AE_WRITABLE事件两类
- 时间事件分为定时事件和周期事件
- 服务器一般只有serverCron函数一个时间事件
- 文件事件和时间事件之间是合作关系，服务器会轮流处理两种事件，并不会进行抢占
- 时间事件的实际处理时间通常会比设定的晚一些
  